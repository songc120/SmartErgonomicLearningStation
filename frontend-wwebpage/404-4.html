<!DOCTYPE html>
<html lang="en">
<head>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
  <meta charset="UTF-8">
  <title>Desk Usage Timeline (Elevation Periods)</title>
  <style>
    body {
  font-family: 'Inter', 'Segoe UI', sans-serif;
  background: #f9f9fb;
  color: #333;
  padding: 20px;
}
    h1 { margin-bottom: 10px; }
    .section { margin-bottom: 30px; }
    .label   { font-weight: bold; margin-bottom: 8px; }
    .stats {
      display: flex;
      gap: 20px;
      margin-bottom: 10px;
      flex-wrap: wrap;
    }
    .card {
  padding: 12px 16px;
  background: rgba(255, 255, 255, 0.6);
  border: 1px solid #e0e0e0;
  border-radius: 12px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.06);
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
  transition: box-shadow 0.3s ease;
}
    .range-label {
      font-size: 14px;
      margin-bottom: 20px;
      color: #666;
      text-align: center;
    }
    .log-table {
      width: 100%;
      border-collapse: collapse;
    }
    .log-table th, .log-table td {
      border: 1px solid #ddd;
      padding: 6px 8px;
      font-size: 13px;
    }
    .log-table th {
      background-color: #f0f0f0;
      text-align: left;
    }
    .ring-container {
  position: relative;
  width: 100%;
  max-width: 360px;
  aspect-ratio: 1 / 1;
  margin-bottom: 20px;
  flex: 1;
  background: transparent;
  border-radius: 100%;
  box-shadow: none;
}
    .ring-canvas {
      width: 100%;
      height: 100%;
    }
    .circle-overlay {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 14px;
  font-weight: normal;
  text-align: center;
  color: #444;
}
  </style>
</head>
<body>
  <h1 id="mainTitle" style="text-align:center;">Desk Usage Timeline</h1>
  <div class="range-label" id="timeRangeLabel"></div>

  <div class="section">
  <div class="label">Presence & Elevation Timelines (Circular)</div>
  <div style="display: flex; gap: 40px; flex-wrap: wrap; justify-content: center;">
    <div class="ring-container">
      <canvas id="presenceCanvas" class="ring-canvas"></canvas>
      <div class="circle-overlay">
        <div><strong>Presence</strong></div>
        <div style="font-size:12px; line-height:1.4; margin-top:4px;">
          üü© Present<br>
          ‚¨ú Absent
        </div>
      </div>
    </div>
    <div class="ring-container">
      <canvas id="elevationCanvas" class="ring-canvas"></canvas>
      <div class="circle-overlay">
        <div><strong>Elevation</strong></div>
        <div style="font-size:12px; line-height:1.4; margin-top:4px;">
          üü¶ Up<br>
          üü• Down<br>
          ‚¨ú Steady
        </div>
      </div>
    </div>
  </div>
</div>
  
  </div>
  <div class="section">
    <div class="label">Quick Stats</div>
    <div class="stats" id="statsPanel"></div>
  </div>

  <div class="section">
    <div class="label">Motion Event Log</div>
    <table class="log-table" id="logTable">
      <thead>
        <tr><th>Time</th><th>Presence</th><th>Elevation</th></tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

<script>
function drawRing(canvasId, timeline, stateMap, colorMap) {
  const canvas = document.getElementById(canvasId);
  const ctx = canvas.getContext("2d");
  const size = canvas.width = canvas.height = canvas.offsetWidth;
  ctx.fillStyle = '#f9f9fb';
  ctx.fillRect(0, 0, size, size);
  const cx = size / 2, cy = size / 2, r = size / 2 - 10;
  const total = timeline.length;
  canvas.onmousemove = (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left - cx;
    const y = e.clientY - rect.top - cy;
    const angle = (Math.atan2(y, x) + Math.PI * 2 + Math.PI / 2) % (Math.PI * 2);
    const index = Math.floor(angle / (2 * Math.PI) * total);
    const time = timeline[index];
    canvas.title = `${canvasId}: ${time}`;
  };
  let i = 0;
  function animate() {
    if (i >= timeline.length) return;
    const t = timeline[i];
    const angleStart = ((i / total) * 2 * Math.PI) - Math.PI / 2;
    const angleEnd = (((i + 1) / total) * 2 * Math.PI) - Math.PI / 2;
    ctx.beginPath();
    ctx.strokeStyle = colorMap[stateMap[t]] || "#e5e7eb";
    ctx.lineWidth = 10;
    ctx.arc(cx, cy, r, angleStart, angleEnd);
    ctx.stroke();
    i++;
    requestAnimationFrame(animate);
  }
  animate();

  // draw hour ticks
  for (let h = 0; h < 12; h++) {
    const angle = (h / 12) * 2 * Math.PI - Math.PI / 2;
    const innerR = r - 10;
    const outerR = r + 2;
    const x1 = cx + Math.cos(angle) * innerR;
    const y1 = cy + Math.sin(angle) * innerR;
    const x2 = cx + Math.cos(angle) * outerR;
    const y2 = cy + Math.sin(angle) * outerR;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.strokeStyle = '#ccc';
    ctx.lineWidth = 1;
    ctx.stroke();
  }
  animate();
  // draw hour ticks
  for (let h = 0; h < 12; h++) {
    const angle = (h / 12) * 2 * Math.PI - Math.PI / 2;
    const innerR = r - 10;
    const outerR = r + 2;
    const x1 = cx + Math.cos(angle) * innerR;
    const y1 = cy + Math.sin(angle) * innerR;
    const x2 = cx + Math.cos(angle) * outerR;
    const y2 = cy + Math.sin(angle) * outerR;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.strokeStyle = '#ccc';
    ctx.lineWidth = 1;
    ctx.stroke();
  }

}

async function loadData() {
  let standingSeconds = 0;
  let sittingSeconds = 0;
  const motionRes = await fetch("motion_sensor_log.json");
  const elevRes = await fetch("motion_log.json");
  const motionLog = (await motionRes.json()).sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
  const elevationLog = await elevRes.json();

  const presenceMap = {};
  for (let i = 0; i < motionLog.length - 1; i++) {
    const start = new Date(motionLog[i].timestamp);
    const end = new Date(motionLog[i + 1].timestamp);
    const state = motionLog[i].gpio_state === 1 ? "present" : "absent";
    const cursor = new Date(start);
    while (cursor <= end) {
      const key = cursor.toISOString().slice(0, 19);
      presenceMap[key] = state;
      cursor.setSeconds(cursor.getSeconds() + 1);
    }
  }

  const motionTimes = motionLog.map(e => new Date(e.timestamp));
  const elevationTimes = elevationLog.map(e => new Date(e.timestamp * 1000));
  const allTimes = motionTimes.concat(elevationTimes);
  const startTime = new Date(Math.min(...allTimes.map(d => d.getTime())));
  const endTime = new Date(Math.max(...allTimes.map(d => d.getTime())));
  document.getElementById("mainTitle").innerText += ` ¬∑ ${startTime.toISOString().slice(0, 10)}`;
  document.getElementById("timeRangeLabel").innerText = `üïí Time Range: ${startTime.toLocaleTimeString()} ‚Äî ${endTime.toLocaleTimeString()}`;

  const timeline = [];
  const cursor = new Date(startTime);
  while (cursor <= endTime) {
    timeline.push(cursor.toISOString().slice(0, 19));
    cursor.setSeconds(cursor.getSeconds() + 1);
  }

  const elevationMap = {};
  let lastState = "steady";
  let lastTime = new Date(startTime);
  elevationLog.forEach(e => {
    const thisTime = new Date(e.timestamp * 1000);
    const newState = e.signal === 2 ? "up" : e.signal === 1 ? "down" : lastState;
    const cursor = new Date(lastTime);
    while (cursor < thisTime) {
      const key = cursor.toISOString().slice(0, 19);
      elevationMap[key] = lastState;
      cursor.setSeconds(cursor.getSeconds() + 1);
    }
    lastTime = thisTime;
    lastState = newState;
  });
  const endCursor = new Date(lastTime);
  while (endCursor <= endTime) {
    const key = endCursor.toISOString().slice(0, 19);
    elevationMap[key] = lastState;
    endCursor.setSeconds(endCursor.getSeconds() + 1);
  }

  let presentSeconds = 0, upSeconds = 0, downSeconds = 0, absentSeconds = 0;
  const eventLog = [];
  timeline.forEach(t => {
    const p = presenceMap[t] || "absent";
    const e = elevationMap[t];
    if (p === "present") presentSeconds++;
    if (p === "absent") absentSeconds++;
    if (e === "up") upSeconds++;
    if (e === "down") downSeconds++;
    if (p === "present" && e === "up") standingSeconds++;
    if (p === "present" && e === "down") sittingSeconds++;
    eventLog.push({ time: t.split("T")[1], presence: p, elevation: e });
  });

  drawRing("presenceCanvas", timeline, presenceMap, {
    present: "#a7f3d0",
    absent: "#f3f4f6"
  });
  drawRing("elevationCanvas", timeline, elevationMap, {
    up: "#bfdbfe",
    down: "#fecaca",
    steady: "#e5e7eb"
  });

  document.getElementById("statsPanel").innerHTML = `
    <div class="card">üßç Time Present: <b>${Math.floor(presentSeconds/60)}m ${presentSeconds%60}s</b></div>
    <div class="card">‚¨ÜÔ∏è Desk Up Time: <b>${Math.floor(upSeconds/60)}m ${upSeconds%60}s</b></div>
    <div class="card">‚¨áÔ∏è Desk Down Time: <b>${Math.floor(downSeconds/60)}m ${downSeconds%60}s</b></div>
    <div class="card">üßç‚Äç‚ôÇÔ∏è Standing Time: <b>${Math.floor(standingSeconds/60)}m ${standingSeconds%60}s</b></div>
    <div class="card">ü™ë Sitting Time: <b>${Math.floor(sittingSeconds/60)}m ${sittingSeconds%60}s</b></div>
  `;

  const logBody = document.querySelector("#logTable tbody");
  eventLog.forEach(e => {
    logBody.innerHTML += `<tr><td>${e.time}</td><td>${e.presence}</td><td>${e.elevation}</td></tr>`;
  });
}
loadData();
</script>
</body>
</html>
